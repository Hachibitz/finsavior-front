{"ast":null,"code":"/* tslint:disable:max-file-line-count */\n// todo: should we support enforce focus in?\n// todo: in original bs there are was a way to prevent modal from showing\n// todo: original modal had resize events\nimport { Directive, ElementRef, EventEmitter, HostListener, Input, Output, Renderer, ViewContainerRef } from '@angular/core';\nimport { document } from '../utils/facade/browser';\nimport { isBs3 } from '../utils/ng2-bootstrap-config';\nimport { Utils } from '../utils/utils.class';\nimport { ModalBackdropComponent } from './modal-backdrop.component';\nimport { ClassName, modalConfigDefaults, Selector } from './modal-options.class';\nimport { window } from '../utils/facade/browser';\nimport { ComponentLoaderFactory } from '../component-loader/component-loader.factory';\nvar TRANSITION_DURATION = 300;\nvar BACKDROP_TRANSITION_DURATION = 150;\n/** Mark any code with directive to show it's content in modal */\nexport var ModalDirective = function () {\n  function ModalDirective(_element, _viewContainerRef, _renderer, clf) {\n    /** This event fires immediately when the `show` instance method is called. */\n    this.onShow = new EventEmitter();\n    /** This event is fired when the modal has been made visible to the user (will wait for CSS transitions to complete) */\n    this.onShown = new EventEmitter();\n    /** This event is fired immediately when the hide instance method has been called. */\n    this.onHide = new EventEmitter();\n    /** This event is fired when the modal has finished being hidden from the user (will wait for CSS transitions to complete). */\n    this.onHidden = new EventEmitter();\n    // seems like an Options\n    this.isAnimated = true;\n    this._isShown = false;\n    this.isBodyOverflowing = false;\n    this.originalBodyPadding = 0;\n    this.scrollbarWidth = 0;\n    this.timerHideModal = 0;\n    this.timerRmBackDrop = 0;\n    this._element = _element;\n    this._renderer = _renderer;\n    this._backdrop = clf.createLoader(_element, _viewContainerRef, _renderer);\n  }\n  Object.defineProperty(ModalDirective.prototype, \"config\", {\n    get: function () {\n      return this._config;\n    },\n    /** allows to set modal configuration via element property */\n    set: function (conf) {\n      this._config = this.getConfig(conf);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ModalDirective.prototype, \"isShown\", {\n    get: function () {\n      return this._isShown;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  ModalDirective.prototype.onClick = function (event) {\n    if (this.config.ignoreBackdropClick || this.config.backdrop === 'static' || event.target !== this._element.nativeElement) {\n      return;\n    }\n    this.hide(event);\n  };\n  // todo: consider preventing default and stopping propagation\n  ModalDirective.prototype.onEsc = function () {\n    if (this.config.keyboard) {\n      this.hide();\n    }\n  };\n  ModalDirective.prototype.ngOnDestroy = function () {\n    this.config = void 0;\n    if (this._isShown) {\n      this._isShown = false;\n      this.hideModal();\n      this._backdrop.dispose();\n    }\n  };\n  ModalDirective.prototype.ngAfterViewInit = function () {\n    this._config = this._config || this.getConfig();\n    if (this._config.show) {\n      this.show();\n    }\n  };\n  /* Public methods */\n  /** Allows to manually toggle modal visibility */\n  ModalDirective.prototype.toggle = function () {\n    return this._isShown ? this.hide() : this.show();\n  };\n  /** Allows to manually open modal */\n  ModalDirective.prototype.show = function () {\n    var _this = this;\n    this.onShow.emit(this);\n    if (this._isShown) {\n      return;\n    }\n    clearTimeout(this.timerHideModal);\n    clearTimeout(this.timerRmBackDrop);\n    this._isShown = true;\n    this.checkScrollbar();\n    this.setScrollbar();\n    if (document && document.body) {\n      this._renderer.setElementClass(document.body, ClassName.OPEN, true);\n    }\n    this.showBackdrop(function () {\n      _this.showElement();\n    });\n  };\n  /** Allows to manually close modal */\n  ModalDirective.prototype.hide = function (event) {\n    var _this = this;\n    if (event) {\n      event.preventDefault();\n    }\n    this.onHide.emit(this);\n    // todo: add an option to prevent hiding\n    if (!this._isShown) {\n      return;\n    }\n    clearTimeout(this.timerHideModal);\n    clearTimeout(this.timerRmBackDrop);\n    this._isShown = false;\n    this._renderer.setElementClass(this._element.nativeElement, ClassName.IN, false);\n    if (!isBs3()) {\n      this._renderer.setElementClass(this._element.nativeElement, ClassName.SHOW, false);\n    }\n    // this._addClassIn = false;\n    if (this.isAnimated) {\n      this.timerHideModal = setTimeout(function () {\n        return _this.hideModal();\n      }, TRANSITION_DURATION);\n    } else {\n      this.hideModal();\n    }\n  };\n  /** Private methods @internal */\n  ModalDirective.prototype.getConfig = function (config) {\n    return Object.assign({}, modalConfigDefaults, config);\n  };\n  /**\n   *  Show dialog\n   *  @internal\n   */\n  ModalDirective.prototype.showElement = function () {\n    var _this = this;\n    // todo: replace this with component loader usage\n    if (!this._element.nativeElement.parentNode || this._element.nativeElement.parentNode.nodeType !== Node.ELEMENT_NODE) {\n      // don't move modals dom position\n      if (document && document.body) {\n        document.body.appendChild(this._element.nativeElement);\n      }\n    }\n    this._renderer.setElementAttribute(this._element.nativeElement, 'aria-hidden', 'false');\n    this._renderer.setElementStyle(this._element.nativeElement, 'display', 'block');\n    this._renderer.setElementProperty(this._element.nativeElement, 'scrollTop', 0);\n    if (this.isAnimated) {\n      Utils.reflow(this._element.nativeElement);\n    }\n    // this._addClassIn = true;\n    this._renderer.setElementClass(this._element.nativeElement, ClassName.IN, true);\n    if (!isBs3()) {\n      this._renderer.setElementClass(this._element.nativeElement, ClassName.SHOW, true);\n    }\n    var transitionComplete = function () {\n      if (_this._config.focus) {\n        _this._element.nativeElement.focus();\n      }\n      _this.onShown.emit(_this);\n    };\n    if (this.isAnimated) {\n      setTimeout(transitionComplete, TRANSITION_DURATION);\n    } else {\n      transitionComplete();\n    }\n  };\n  /** @internal */\n  ModalDirective.prototype.hideModal = function () {\n    var _this = this;\n    this._renderer.setElementAttribute(this._element.nativeElement, 'aria-hidden', 'true');\n    this._renderer.setElementStyle(this._element.nativeElement, 'display', 'none');\n    this.showBackdrop(function () {\n      if (document && document.body) {\n        _this._renderer.setElementClass(document.body, ClassName.OPEN, false);\n      }\n      _this.resetAdjustments();\n      _this.resetScrollbar();\n      _this.onHidden.emit(_this);\n    });\n  };\n  // todo: original show was calling a callback when done, but we can use promise\n  /** @internal */\n  ModalDirective.prototype.showBackdrop = function (callback) {\n    var _this = this;\n    if (this._isShown && this.config.backdrop && (!this.backdrop || !this.backdrop.instance.isShown)) {\n      this.removeBackdrop();\n      this._backdrop.attach(ModalBackdropComponent).to('body').show({\n        isAnimated: false\n      });\n      this.backdrop = this._backdrop._componentRef;\n      if (this.isAnimated) {\n        this.backdrop.instance.isAnimated = this.isAnimated;\n        Utils.reflow(this.backdrop.instance.element.nativeElement);\n      }\n      this.backdrop.instance.isShown = true;\n      if (!callback) {\n        return;\n      }\n      if (!this.isAnimated) {\n        callback();\n        return;\n      }\n      setTimeout(callback, BACKDROP_TRANSITION_DURATION);\n    } else if (!this._isShown && this.backdrop) {\n      this.backdrop.instance.isShown = false;\n      var callbackRemove = function () {\n        _this.removeBackdrop();\n        if (callback) {\n          callback();\n        }\n      };\n      if (this.backdrop.instance.isAnimated) {\n        this.timerRmBackDrop = setTimeout(callbackRemove, BACKDROP_TRANSITION_DURATION);\n      } else {\n        callbackRemove();\n      }\n    } else if (callback) {\n      callback();\n    }\n  };\n  /** @internal */\n  ModalDirective.prototype.removeBackdrop = function () {\n    this._backdrop.hide();\n  };\n  /** Events tricks */\n  // no need for it\n  // protected setEscapeEvent():void {\n  //   if (this._isShown && this._config.keyboard) {\n  //     $(this._element).on(Event.KEYDOWN_DISMISS, (event) => {\n  //       if (event.which === 27) {\n  //         this.hide()\n  //       }\n  //     })\n  //\n  //   } else if (!this._isShown) {\n  //     $(this._element).off(Event.KEYDOWN_DISMISS)\n  //   }\n  // }\n  // protected setResizeEvent():void {\n  // console.log(this.renderer.listenGlobal('', Event.RESIZE));\n  // if (this._isShown) {\n  //   $(window).on(Event.RESIZE, $.proxy(this._handleUpdate, this))\n  // } else {\n  //   $(window).off(Event.RESIZE)\n  // }\n  // }\n  /** @internal */\n  ModalDirective.prototype.resetAdjustments = function () {\n    this._renderer.setElementStyle(this._element.nativeElement, 'paddingLeft', '');\n    this._renderer.setElementStyle(this._element.nativeElement, 'paddingRight', '');\n  };\n  /** Scroll bar tricks */\n  /** @internal */\n  ModalDirective.prototype.checkScrollbar = function () {\n    this.isBodyOverflowing = document.body.clientWidth < window.innerWidth;\n    this.scrollbarWidth = this.getScrollbarWidth();\n  };\n  ModalDirective.prototype.setScrollbar = function () {\n    if (!document) {\n      return;\n    }\n    var fixedEl = document.querySelector(Selector.FIXED_CONTENT);\n    if (!fixedEl) {\n      return;\n    }\n    var bodyPadding = parseInt(Utils.getStyles(fixedEl).paddingRight || 0, 10);\n    this.originalBodyPadding = parseInt(document.body.style.paddingRight || 0, 10);\n    if (this.isBodyOverflowing) {\n      document.body.style.paddingRight = bodyPadding + this.scrollbarWidth + \"px\";\n    }\n  };\n  ModalDirective.prototype.resetScrollbar = function () {\n    document.body.style.paddingRight = this.originalBodyPadding;\n  };\n  // thx d.walsh\n  ModalDirective.prototype.getScrollbarWidth = function () {\n    var scrollDiv = this._renderer.createElement(document.body, 'div', void 0);\n    scrollDiv.className = ClassName.SCROLLBAR_MEASURER;\n    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n    document.body.removeChild(scrollDiv);\n    return scrollbarWidth;\n  };\n  ModalDirective.decorators = [{\n    type: Directive,\n    args: [{\n      selector: '[bsModal]',\n      exportAs: 'bs-modal'\n    }]\n  }];\n  /** @nocollapse */\n  ModalDirective.ctorParameters = function () {\n    return [{\n      type: ElementRef\n    }, {\n      type: ViewContainerRef\n    }, {\n      type: Renderer\n    }, {\n      type: ComponentLoaderFactory\n    }];\n  };\n  ModalDirective.propDecorators = {\n    'config': [{\n      type: Input\n    }],\n    'onShow': [{\n      type: Output\n    }],\n    'onShown': [{\n      type: Output\n    }],\n    'onHide': [{\n      type: Output\n    }],\n    'onHidden': [{\n      type: Output\n    }],\n    'onClick': [{\n      type: HostListener,\n      args: ['click', ['$event']]\n    }],\n    'onEsc': [{\n      type: HostListener,\n      args: ['keydown.esc']\n    }]\n  };\n  return ModalDirective;\n}();\n//# sourceMappingURL=modal.component.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
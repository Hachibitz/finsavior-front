{"ast":null,"code":"import { Directive, ElementRef, EventEmitter, HostListener, Input, Output, Renderer, ViewContainerRef } from '@angular/core';\nimport { NgControl } from '@angular/forms';\nimport { TypeaheadContainerComponent } from './typeahead-container.component';\nimport { TypeaheadUtils } from './typeahead-utils';\nimport { Observable } from 'rxjs/Observable';\nimport 'rxjs/add/observable/from';\nimport 'rxjs/add/operator/debounceTime';\nimport 'rxjs/add/operator/filter';\nimport 'rxjs/add/operator/map';\nimport 'rxjs/add/operator/mergeMap';\nimport 'rxjs/add/operator/toArray';\nimport { TypeaheadMatch } from './typeahead-match.class';\nimport { ComponentLoaderFactory } from '../component-loader';\nexport var TypeaheadDirective = function () {\n  function TypeaheadDirective(control, viewContainerRef, element, renderer, cis) {\n    /** minimal no of characters that needs to be entered before typeahead kicks-in. When set to 0, typeahead shows on focus with full list of options (limited as normal by typeaheadOptionsLimit) */\n    this.typeaheadMinLength = void 0;\n    /** should be used only in case of typeahead attribute is array. If true - loading of options will be async, otherwise - sync. true make sense if options array is large. */\n    this.typeaheadAsync = void 0;\n    /** match latin symbols. If true the word s√∫per would match super and vice versa. */\n    this.typeaheadLatinize = true;\n    /** break words with spaces. If true the text \"exact phrase\" here match would match with match exact phrase here but not with phrase here exact match (kind of \"google style\"). */\n    this.typeaheadSingleWords = true;\n    /** should be used only in case typeaheadSingleWords attribute is true. Sets the word delimiter to break words. Defaults to space. */\n    this.typeaheadWordDelimiters = ' ';\n    /** should be used only in case typeaheadSingleWords attribute is true. Sets the word delimiter to match exact phrase. Defaults to simple and double quotes. */\n    this.typeaheadPhraseDelimiters = '\\'\"';\n    /** fired when 'busy' state of this component was changed, fired on async mode only, returns boolean */\n    this.typeaheadLoading = new EventEmitter();\n    /** fired on every key event and returns true in case of matches are not detected */\n    this.typeaheadNoResults = new EventEmitter();\n    /** fired when option was selected, return object with data of this option */\n    this.typeaheadOnSelect = new EventEmitter();\n    /** fired when blur event occurres. returns the active item */\n    this.typeaheadOnBlur = new EventEmitter();\n    this.isTypeaheadOptionsListActive = false;\n    this.keyUpEventEmitter = new EventEmitter();\n    this.placement = 'bottom-left';\n    this.element = element;\n    this.ngControl = control;\n    this.viewContainerRef = viewContainerRef;\n    this.renderer = renderer;\n    this._typeahead = cis.createLoader(element, viewContainerRef, renderer);\n  }\n  TypeaheadDirective.prototype.onChange = function (e) {\n    if (this._container) {\n      // esc\n      if (e.keyCode === 27) {\n        this.hide();\n        return;\n      }\n      // up\n      if (e.keyCode === 38) {\n        this._container.prevActiveMatch();\n        return;\n      }\n      // down\n      if (e.keyCode === 40) {\n        this._container.nextActiveMatch();\n        return;\n      }\n      // enter\n      if (e.keyCode === 13) {\n        this._container.selectActiveMatch();\n        return;\n      }\n    }\n    // For `<input>`s, use the `value` property. For others that don't have a\n    // `value` (such as `<span contenteditable=\"true\">`, use `innerText`.\n    var value = e.target.value !== undefined ? e.target.value : e.target.innerText;\n    if (value.trim().length >= this.typeaheadMinLength) {\n      this.typeaheadLoading.emit(true);\n      this.keyUpEventEmitter.emit(e.target.value);\n    } else {\n      this.typeaheadLoading.emit(false);\n      this.typeaheadNoResults.emit(false);\n      this.hide();\n    }\n  };\n  TypeaheadDirective.prototype.onFocus = function () {\n    if (this.typeaheadMinLength === 0) {\n      this.typeaheadLoading.emit(true);\n      this.keyUpEventEmitter.emit('');\n    }\n  };\n  TypeaheadDirective.prototype.onBlur = function () {\n    if (this._container && !this._container.isFocused) {\n      this.typeaheadOnBlur.emit(this._container.active);\n      this.hide();\n    }\n  };\n  TypeaheadDirective.prototype.onKeydown = function (e) {\n    // no container - no problems\n    if (!this._container) {\n      return;\n    }\n    // if items is visible - prevent form submition\n    if (e.keyCode === 13) {\n      e.preventDefault();\n      return;\n    }\n  };\n  TypeaheadDirective.prototype.ngOnInit = function () {\n    this.typeaheadOptionsLimit = this.typeaheadOptionsLimit || 20;\n    this.typeaheadMinLength = this.typeaheadMinLength === void 0 ? 1 : this.typeaheadMinLength;\n    this.typeaheadWaitMs = this.typeaheadWaitMs || 0;\n    // async should be false in case of array\n    if (this.typeaheadAsync === undefined && !(this.typeahead instanceof Observable)) {\n      this.typeaheadAsync = false;\n    }\n    if (this.typeahead instanceof Observable) {\n      this.typeaheadAsync = true;\n    }\n    if (this.typeaheadAsync) {\n      this.asyncActions();\n    } else {\n      this.syncActions();\n    }\n  };\n  TypeaheadDirective.prototype.changeModel = function (match) {\n    var valueStr = match.value;\n    this.ngControl.viewToModelUpdate(valueStr);\n    this.ngControl.control.setValue(valueStr);\n    this.hide();\n  };\n  Object.defineProperty(TypeaheadDirective.prototype, \"matches\", {\n    get: function () {\n      return this._matches;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  TypeaheadDirective.prototype.show = function () {\n    this._typeahead.attach(TypeaheadContainerComponent).to(this.container).position({\n      attachment: 'bottom left'\n    }).show({\n      typeaheadRef: this,\n      placement: this.placement,\n      animation: false\n    });\n    this._container = this._typeahead.instance;\n    this._container.parent = this;\n    // This improves the speed as it won't have to be done for each list item\n    var normalizedQuery = (this.typeaheadLatinize ? TypeaheadUtils.latinize(this.ngControl.control.value) : this.ngControl.control.value).toString().toLowerCase();\n    this._container.query = this.typeaheadSingleWords ? TypeaheadUtils.tokenize(normalizedQuery, this.typeaheadWordDelimiters, this.typeaheadPhraseDelimiters) : normalizedQuery;\n    this._container.matches = this._matches;\n    this.element.nativeElement.focus();\n  };\n  TypeaheadDirective.prototype.hide = function () {\n    if (this._typeahead.isShown) {\n      this._typeahead.hide();\n      this._container = null;\n    }\n  };\n  TypeaheadDirective.prototype.ngOnDestroy = function () {\n    this._typeahead.dispose();\n  };\n  TypeaheadDirective.prototype.asyncActions = function () {\n    var _this = this;\n    this.keyUpEventEmitter.debounceTime(this.typeaheadWaitMs).mergeMap(function () {\n      return _this.typeahead;\n    }).subscribe(function (matches) {\n      _this.finalizeAsyncCall(matches);\n    }, function (err) {\n      console.error(err);\n    });\n  };\n  TypeaheadDirective.prototype.syncActions = function () {\n    var _this = this;\n    this.keyUpEventEmitter.debounceTime(this.typeaheadWaitMs).mergeMap(function (value) {\n      var normalizedQuery = _this.normalizeQuery(value);\n      return Observable.from(_this.typeahead).filter(function (option) {\n        return option && _this.testMatch(_this.normalizeOption(option), normalizedQuery);\n      }).toArray();\n    }).subscribe(function (matches) {\n      _this.finalizeAsyncCall(matches);\n    }, function (err) {\n      console.error(err);\n    });\n  };\n  TypeaheadDirective.prototype.normalizeOption = function (option) {\n    var optionValue = TypeaheadUtils.getValueFromObject(option, this.typeaheadOptionField);\n    var normalizedOption = this.typeaheadLatinize ? TypeaheadUtils.latinize(optionValue) : optionValue;\n    return normalizedOption.toLowerCase();\n  };\n  TypeaheadDirective.prototype.normalizeQuery = function (value) {\n    // If singleWords, break model here to not be doing extra work on each\n    // iteration\n    var normalizedQuery = (this.typeaheadLatinize ? TypeaheadUtils.latinize(value) : value).toString().toLowerCase();\n    normalizedQuery = this.typeaheadSingleWords ? TypeaheadUtils.tokenize(normalizedQuery, this.typeaheadWordDelimiters, this.typeaheadPhraseDelimiters) : normalizedQuery;\n    return normalizedQuery;\n  };\n  TypeaheadDirective.prototype.testMatch = function (match, test) {\n    var spaceLength;\n    if (typeof test === 'object') {\n      spaceLength = test.length;\n      for (var i = 0; i < spaceLength; i += 1) {\n        if (test[i].length > 0 && match.indexOf(test[i]) < 0) {\n          return false;\n        }\n      }\n      return true;\n    } else {\n      return match.indexOf(test) >= 0;\n    }\n  };\n  TypeaheadDirective.prototype.finalizeAsyncCall = function (matches) {\n    this.prepareMatches(matches);\n    this.typeaheadLoading.emit(false);\n    this.typeaheadNoResults.emit(!this.hasMatches());\n    if (!this.hasMatches()) {\n      this.hide();\n      return;\n    }\n    if (this._container) {\n      // This improves the speed as it won't have to be done for each list item\n      var normalizedQuery = (this.typeaheadLatinize ? TypeaheadUtils.latinize(this.ngControl.control.value) : this.ngControl.control.value).toString().toLowerCase();\n      this._container.query = this.typeaheadSingleWords ? TypeaheadUtils.tokenize(normalizedQuery, this.typeaheadWordDelimiters, this.typeaheadPhraseDelimiters) : normalizedQuery;\n      this._container.matches = this._matches;\n    } else {\n      this.show();\n    }\n  };\n  TypeaheadDirective.prototype.prepareMatches = function (options) {\n    var _this = this;\n    var limited = options.slice(0, this.typeaheadOptionsLimit);\n    if (this.typeaheadGroupField) {\n      var matches_1 = [];\n      // extract all group names\n      var groups = limited.map(function (option) {\n        return TypeaheadUtils.getValueFromObject(option, _this.typeaheadGroupField);\n      }).filter(function (v, i, a) {\n        return a.indexOf(v) === i;\n      });\n      groups.forEach(function (group) {\n        // add group header to array of matches\n        matches_1.push(new TypeaheadMatch(group, group, true));\n        // add each item of group to array of matches\n        matches_1 = matches_1.concat(limited.filter(function (option) {\n          return TypeaheadUtils.getValueFromObject(option, _this.typeaheadGroupField) === group;\n        }).map(function (option) {\n          return new TypeaheadMatch(option, TypeaheadUtils.getValueFromObject(option, _this.typeaheadOptionField));\n        }));\n      });\n      this._matches = matches_1;\n    } else {\n      this._matches = limited.map(function (option) {\n        return new TypeaheadMatch(option, TypeaheadUtils.getValueFromObject(option, _this.typeaheadOptionField));\n      });\n    }\n  };\n  TypeaheadDirective.prototype.hasMatches = function () {\n    return this._matches.length > 0;\n  };\n  TypeaheadDirective.decorators = [{\n    type: Directive,\n    args: [{\n      selector: '[typeahead]',\n      exportAs: 'bs-typeahead'\n    }]\n  }];\n  /** @nocollapse */\n  TypeaheadDirective.ctorParameters = function () {\n    return [{\n      type: NgControl\n    }, {\n      type: ViewContainerRef\n    }, {\n      type: ElementRef\n    }, {\n      type: Renderer\n    }, {\n      type: ComponentLoaderFactory\n    }];\n  };\n  TypeaheadDirective.propDecorators = {\n    'typeahead': [{\n      type: Input\n    }],\n    'typeaheadMinLength': [{\n      type: Input\n    }],\n    'typeaheadWaitMs': [{\n      type: Input\n    }],\n    'typeaheadOptionsLimit': [{\n      type: Input\n    }],\n    'typeaheadOptionField': [{\n      type: Input\n    }],\n    'typeaheadGroupField': [{\n      type: Input\n    }],\n    'typeaheadAsync': [{\n      type: Input\n    }],\n    'typeaheadLatinize': [{\n      type: Input\n    }],\n    'typeaheadSingleWords': [{\n      type: Input\n    }],\n    'typeaheadWordDelimiters': [{\n      type: Input\n    }],\n    'typeaheadPhraseDelimiters': [{\n      type: Input\n    }],\n    'typeaheadItemTemplate': [{\n      type: Input\n    }],\n    'optionsListTemplate': [{\n      type: Input\n    }],\n    'typeaheadLoading': [{\n      type: Output\n    }],\n    'typeaheadNoResults': [{\n      type: Output\n    }],\n    'typeaheadOnSelect': [{\n      type: Output\n    }],\n    'typeaheadOnBlur': [{\n      type: Output\n    }],\n    'container': [{\n      type: Input\n    }],\n    'onChange': [{\n      type: HostListener,\n      args: ['keyup', ['$event']]\n    }],\n    'onFocus': [{\n      type: HostListener,\n      args: ['focus']\n    }],\n    'onBlur': [{\n      type: HostListener,\n      args: ['blur']\n    }],\n    'onKeydown': [{\n      type: HostListener,\n      args: ['keydown', ['$event']]\n    }]\n  };\n  return TypeaheadDirective;\n}();\n//# sourceMappingURL=typeahead.directive.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
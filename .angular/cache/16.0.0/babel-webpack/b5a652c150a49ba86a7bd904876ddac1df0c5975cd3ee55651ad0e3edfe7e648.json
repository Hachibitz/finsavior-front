{"ast":null,"code":"// todo: add animation\nimport { Component, Input, Output, EventEmitter } from '@angular/core';\nimport { isBs3, LinkedList } from '../utils';\nimport { CarouselConfig } from './carousel.config';\nexport var Direction = /*#__PURE__*/(() => {\n  Direction = Direction || {};\n  Direction[Direction[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  Direction[Direction[\"NEXT\"] = 1] = \"NEXT\";\n  Direction[Direction[\"PREV\"] = 2] = \"PREV\";\n  return Direction;\n})();\n/**\n * Base element to create carousel\n */\nexport var CarouselComponent = function () {\n  function CarouselComponent(config) {\n    /** Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property */\n    this.activeSlideChange = new EventEmitter(false);\n    this._slides = new LinkedList();\n    this.destroyed = false;\n    Object.assign(this, config);\n  }\n  Object.defineProperty(CarouselComponent.prototype, \"activeSlide\", {\n    get: function () {\n      return this._currentActiveSlide;\n    },\n    /** Index of currently displayed slide(started for 0) */\n    set: function (index) {\n      if (this._slides.length && index !== this._currentActiveSlide) {\n        this._select(index);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CarouselComponent.prototype, \"interval\", {\n    /**\n     * Delay of item cycling in milliseconds. If false, carousel won't cycle automatically.\n     */\n    get: function () {\n      return this._interval;\n    },\n    set: function (value) {\n      this._interval = value;\n      this.restartTimer();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CarouselComponent.prototype, \"slides\", {\n    get: function () {\n      return this._slides.toArray();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CarouselComponent.prototype, \"isBs4\", {\n    get: function () {\n      return !isBs3();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  CarouselComponent.prototype.ngOnDestroy = function () {\n    this.destroyed = true;\n  };\n  /**\n   * Adds new slide. If this slide is first in collection - set it as active and starts auto changing\n   * @param slide\n   */\n  CarouselComponent.prototype.addSlide = function (slide) {\n    this._slides.add(slide);\n    if (this._slides.length === 1) {\n      this._currentActiveSlide = void 0;\n      this.activeSlide = 0;\n      this.play();\n    }\n  };\n  /**\n   * Removes specified slide. If this slide is active - will roll to another slide\n   * @param slide\n   */\n  CarouselComponent.prototype.removeSlide = function (slide) {\n    var _this = this;\n    var remIndex = this._slides.indexOf(slide);\n    if (this._currentActiveSlide === remIndex) {\n      // removing of active slide\n      var nextSlideIndex_1 = void 0;\n      if (this._slides.length > 1) {\n        // if this slide last - will roll to first slide, if noWrap flag is FALSE or to previous, if noWrap is TRUE\n        // in case, if this slide in middle of collection, index of next slide is same to removed\n        nextSlideIndex_1 = !this.isLast(remIndex) ? remIndex : this.noWrap ? remIndex - 1 : 0;\n      }\n      this._slides.remove(remIndex);\n      // prevents exception with changing some value after checking\n      setTimeout(function () {\n        _this._select(nextSlideIndex_1);\n      }, 0);\n    } else {\n      this._slides.remove(remIndex);\n      var currentSlideIndex_1 = this.getCurrentSlideIndex();\n      setTimeout(function () {\n        // after removing, need to actualize index of current active slide\n        _this._currentActiveSlide = currentSlideIndex_1;\n        _this.activeSlideChange.emit(_this._currentActiveSlide);\n      }, 0);\n    }\n  };\n  /**\n   * Rolling to next slide\n   * @param force: {boolean} if true - will ignore noWrap flag\n   */\n  CarouselComponent.prototype.nextSlide = function (force) {\n    if (force === void 0) {\n      force = false;\n    }\n    this.activeSlide = this.findNextSlideIndex(Direction.NEXT, force);\n  };\n  /**\n   * Rolling to previous slide\n   * @param force: {boolean} if true - will ignore noWrap flag\n   */\n  CarouselComponent.prototype.previousSlide = function (force) {\n    if (force === void 0) {\n      force = false;\n    }\n    this.activeSlide = this.findNextSlideIndex(Direction.PREV, force);\n  };\n  /**\n   * Rolling to specified slide\n   * @param index: {number} index of slide, which must be shown\n   */\n  CarouselComponent.prototype.selectSlide = function (index) {\n    this.activeSlide = index;\n  };\n  /**\n   * Starts a auto changing of slides\n   */\n  CarouselComponent.prototype.play = function () {\n    if (!this.isPlaying) {\n      this.isPlaying = true;\n      this.restartTimer();\n    }\n  };\n  /**\n   * Stops a auto changing of slides\n   */\n  CarouselComponent.prototype.pause = function () {\n    if (!this.noPause) {\n      this.isPlaying = false;\n      this.resetTimer();\n    }\n  };\n  /**\n   * Finds and returns index of currently displayed slide\n   * @returns {number}\n   */\n  CarouselComponent.prototype.getCurrentSlideIndex = function () {\n    return this._slides.findIndex(function (slide) {\n      return slide.active;\n    });\n  };\n  /**\n   * Defines, whether the specified index is last in collection\n   * @param index\n   * @returns {boolean}\n   */\n  CarouselComponent.prototype.isLast = function (index) {\n    return index + 1 >= this._slides.length;\n  };\n  /**\n   * Defines next slide index, depending of direction\n   * @param direction: Direction(UNKNOWN|PREV|NEXT)\n   * @param force: {boolean} if TRUE - will ignore noWrap flag, else will return undefined if next slide require wrapping\n   * @returns {any}\n   */\n  CarouselComponent.prototype.findNextSlideIndex = function (direction, force) {\n    var nextSlideIndex = 0;\n    if (!force && this.isLast(this.activeSlide) && direction !== Direction.PREV && this.noWrap) {\n      return void 0;\n    }\n    switch (direction) {\n      case Direction.NEXT:\n        // if this is last slide, not force, looping is disabled and need to going forward - select current slide, as a next\n        nextSlideIndex = !this.isLast(this._currentActiveSlide) ? this._currentActiveSlide + 1 : !force && this.noWrap ? this._currentActiveSlide : 0;\n        break;\n      case Direction.PREV:\n        // if this is first slide, not force, looping is disabled and need to going backward - select current slide, as a next\n        nextSlideIndex = this._currentActiveSlide > 0 ? this._currentActiveSlide - 1 : !force && this.noWrap ? this._currentActiveSlide : this._slides.length - 1;\n        break;\n      default:\n        throw new Error('Unknown direction');\n    }\n    return nextSlideIndex;\n  };\n  /**\n   * Sets a slide, which specified through index, as active\n   * @param index\n   * @private\n   */\n  CarouselComponent.prototype._select = function (index) {\n    if (isNaN(index)) {\n      this.pause();\n      return;\n    }\n    var currentSlide = this._slides.get(this._currentActiveSlide);\n    if (currentSlide) {\n      currentSlide.active = false;\n    }\n    var nextSlide = this._slides.get(index);\n    if (nextSlide) {\n      this._currentActiveSlide = index;\n      nextSlide.active = true;\n      this.activeSlide = index;\n      this.activeSlideChange.emit(index);\n    }\n  };\n  /**\n   * Starts loop of auto changing of slides\n   */\n  CarouselComponent.prototype.restartTimer = function () {\n    var _this = this;\n    this.resetTimer();\n    var interval = +this.interval;\n    if (!isNaN(interval) && interval > 0) {\n      this.currentInterval = setInterval(function () {\n        var nInterval = +_this.interval;\n        if (_this.isPlaying && !isNaN(_this.interval) && nInterval > 0 && _this.slides.length) {\n          _this.nextSlide();\n        } else {\n          _this.pause();\n        }\n      }, interval);\n    }\n  };\n  /**\n   * Stops loop of auto changing of slides\n   */\n  CarouselComponent.prototype.resetTimer = function () {\n    if (this.currentInterval) {\n      clearInterval(this.currentInterval);\n      this.currentInterval = void 0;\n    }\n  };\n  CarouselComponent.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'carousel',\n      template: \"\\n    <div (mouseenter)=\\\"pause()\\\" (mouseleave)=\\\"play()\\\" (mouseup)=\\\"play()\\\" class=\\\"carousel slide\\\">\\n      <ol class=\\\"carousel-indicators\\\" *ngIf=\\\"slides.length > 1\\\">\\n         <li *ngFor=\\\"let slidez of slides; let i = index;\\\" [class.active]=\\\"slidez.active === true\\\" (click)=\\\"selectSlide(i)\\\"></li>\\n      </ol>\\n      <div class=\\\"carousel-inner\\\"><ng-content></ng-content></div>\\n      <a class=\\\"left carousel-control carousel-control-prev\\\" [class.disabled]=\\\"activeSlide === 0 && noWrap\\\" (click)=\\\"previousSlide()\\\" *ngIf=\\\"slides.length > 1\\\">\\n        <span class=\\\"icon-prev carousel-control-prev-icon\\\" aria-hidden=\\\"true\\\"></span>\\n        <span *ngIf=\\\"isBs4\\\" class=\\\"sr-only\\\">Previous</span>\\n      </a>\\n      <a class=\\\"right carousel-control carousel-control-next\\\" (click)=\\\"nextSlide()\\\"  [class.disabled]=\\\"isLast(activeSlide) && noWrap\\\" *ngIf=\\\"slides.length > 1\\\">\\n        <span class=\\\"icon-next carousel-control-next-icon\\\" aria-hidden=\\\"true\\\"></span>\\n        <span class=\\\"sr-only\\\">Next</span>\\n      </a>\\n    </div>\\n  \"\n    }]\n  }];\n  /** @nocollapse */\n  CarouselComponent.ctorParameters = function () {\n    return [{\n      type: CarouselConfig\n    }];\n  };\n  CarouselComponent.propDecorators = {\n    'noWrap': [{\n      type: Input\n    }],\n    'noPause': [{\n      type: Input\n    }],\n    'activeSlideChange': [{\n      type: Output\n    }],\n    'activeSlide': [{\n      type: Input\n    }],\n    'interval': [{\n      type: Input\n    }]\n  };\n  return CarouselComponent;\n}();\n//# sourceMappingURL=carousel.component.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}